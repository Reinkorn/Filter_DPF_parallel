#include <stdio.h>// Cтандартная библиотека ввода вывода
#include <iostream> // Библиотека для работы cout и сin в С++
#include <time.h> // Библиотека для работы со временем
#include <omp.h> // Библиотека для распараллеливания
#include <vector> // Библиотека для работы с векторами
#include <cmath> // Библиотека математических расчётов

using namespace std; // Используем стандартное пространство имён std

void NoParallel() // Создаём функцию которая будет фильтравать синусоидальный сигнал методом ЦФ фурье
{
    int n;// Определяем переменную определяющую размер массива
    double t1,t2; // Инициализируем переменные для начала и завершения отсчёта времени
    cout<<"Vvedite chetnoe chislo opredeliaushee razmer viborki n: ";
    cin>>n;
    srand(0);
    vector <float> x;//Создаём вектор для нашей функции синуса
    vector <float> y;//Создаём вектор для нашей для нашей отфильтрованной функции синуса
    vector <float> c;//Для модуля квадратурных компонент
    vector <float> a;//Создаём вектор для коэффициентов фурье
    vector <float> b;// Вектор для функции после фильтрации(инициализируем её)
    x.reserve(n);// Опрделяем количество ячеек в векторе
    y.reserve(n);// Опрделяем количество ячеек в векторе
    a.reserve(n/2);// Опрделяем количество ячеек в векторе
    b.reserve(n/2);// Опрделяем количество ячеек в векторе
    c.reserve(n/2);// Опрделяем количество ячеек в векторе

    for (int i = 0; i < n; i++)
        {
            x[i] = sin(i*0.05);//аргумент синуса задаётся в радианах
        }

    for (int i = 0; i < n; i++)
        {
            x[i]+= 0.1* (1.*(1-(-1)*rand()/RAND_MAX - 1));//добавляем случайное число от -0.1 до 0.1
        }
    //Прямое преобразование Фурье
    float a1 = 0;
    float b1 = 0;
    t1=omp_get_wtime();
    for (int i = 0; i < n/2; i++)
    {
        for (int j= 0; j < n; j++)
        {
            a1+=((1/n)*(x[j])*cos((2*3.14)/(n*i*j)));
            b1+=((1/n)*(x[j])*sin((2*3.14)/(n*i*j)));
        }
        a[i]+=a1;
        b[i]+=b1;
        a1 = 0;
        b1 = 0;
    }

    for (int i = 0; i < n/2; i++)
    {
        c[i]+=sqrt(a[i]*a[i]+ b[i]*b[i]);
    }
    //Далее делаем обратное преобразование Фурье


    float y1 = 0;
    for (int j= 0; j < n; j++)
    {
        for (int i = 0; i < n/2; i++)
        {
            y1+=(2*(a[i]*cos(2*(3.14/n)*j*i)+ b[i]*sin(2*(3.14/n)*j*i)));
        }
        y[j]+= y1;
        y1 = 0;
    }
    t2=omp_get_wtime();
    cout<< "NoParallel time: "<<t2-t1<<endl;
    //Фильтрация выполнена и в нашем векторе y теперь лежит отфильтрованный синус при помощи ДПФ(Дискретное преобразование Фурье)
    //for (int i = 0; i < n; i++)
    //{
    //    cout << y[i];
    //}
}
void Parallel() // Создаём функцию которая будет фильтравать синусоидальный сигнал методом ДПФ паралельно
{
    int n;
    int Z;

    double t1,t2;
    cout<<"Vvedite chetnoe chislo opredeliaushee razmer viborki n: ";
    cin>>n;
    cout<<"Quantity active Kernel Z: ";
    cin>>Z;
    srand(0);
    vector <float> x;//Создаём вектор для нашей функции синуса
    vector <float> y;//Создаём вектор для нашей для нашей отфильтрованной функции синуса
    vector <float> c;//Для модуля квадратурных компонент
    vector <float> a;//Создаём вектор для коэффициентов фурье
    vector <float> b;// Вектор для функции после фильтрации(инициализируем её)
    x.reserve(n);// Опрделяем количество ячеек в векторе
    y.reserve(n);// Опрделяем количество ячеек в векторе
    a.reserve(n/2);// Опрделяем количество ячеек в векторе
    b.reserve(n/2);// Опрделяем количество ячеек в векторе
    c.reserve(n/2);// Опрделяем количество ячеек в векторе

    for (int i = 0; i < n; i++)
        {
            x[i] = sin(i*0.05);//аргумент синуса задаётся в радианах
        }

    for (int i = 0; i < n; i++)
        {
            x[i]+= 0.1* (1.*(1-(-1)*rand()/RAND_MAX - 1));//добавляем случайное число от -0.1 до 0.1
        }
    //Прямое преобразование Фурье
    float a1 = 0;
    float b1 = 0;
    t1=omp_get_wtime();//Начинаем отсчёт времени

    #pragma omp parallel for num_threads(Z)//Распараллеливаем цикл
    for (int i = 0; i < n/2; i++)
    {
        for (int j= 0; j < n; j++)
        {
            a1+=((1/n)*(x[j])*cos((2*3.14)/(n*i*j)));
            b1+=((1/n)*(x[j])*sin((2*3.14)/(n*i*j)));
        }
        a[i]+=a1;
        b[i]+=b1;
        a1 = 0;
        b1 = 0;
    }

    #pragma omp parallel for num_threads(Z)//Расспараллеливаем цикл
    for (int i = 0; i < n/2; i++)
    {
        c[i]+=sqrt(a[i]*a[i]+ b[i]*b[i]);// Cчитаем модуль коэффициентов Фурье
    }
    //Далее делаем обратное преобразование Фурье


    float y1 = 0;
    #pragma omp parallel for num_threads(Z)//Расспараллеливаем цикл
    for (int j= 0; j < n; j++)
    {
        for (int i = 0; i < n/2; i++)
        {
            y1+=(2*(a[i]*cos(2*(3.14/n)*j*i)+ b[i]*sin(2*(3.14/n)*j*i)));
        }
        y[j]+= y1;
        y1 = 0;
    }
    t2=omp_get_wtime();//Завершаем отсчёт времени
    cout<< "Parallel time: "<<t2-t1<<endl;//Выводим время выполнения
    //Фильтрация выполнена и в нашем векторе y теперь лежит отфильтрованный синус при помощи ДПФ(Дискретное преобразование Фурье)

    //for (int i = 0; i < n; i++)
    //{
    //    cout << y[i];//Если хотим посмотреть что внутри вектора на выходе
    //}
}

int main()
{
    NoParallel();// Вызываем не распараллеленную функцию
    Parallel();// Вызываем распаралелленую функцию

    system("pause");

    return 0;
}
